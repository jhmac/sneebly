import fs from "fs";
import path from "path";
import { generatePlan, loadCurrentPlan, getNextStep, cancelPlan } from "./planner-agent";
import { executeStep, rollbackFiles } from "./builder-agent";
import { verifyChanges, quickHealthCheck, quickStepVerify } from "./verify-agent";
import { getCompletionPercent, markGoalComplete, generateProgressReport } from "./progress-tracker";
import { getBudgetLimits } from "./identity";
import { getCostSummary } from "./cost-tracker";
import { triggerAutoFixer } from "./auto-fixer";
import { runLearningCycle } from "./learning-loop";
import { callClaude, extractJson } from "./utils";
import { isPathSafe } from "./path-safety";
import { getSafePaths, getNeverModifyPaths } from "./identity";

const NEEDS_ATTENTION_FILE = path.join(process.cwd(), "NEEDS-ATTENTION.md");

function writeNeedsAttention(cycle: number, result: string, step: string | null, error: string | null): void {
  try {
    const timestamp = new Date().toISOString();
    const header = fs.existsSync(NEEDS_ATTENTION_FILE) ? "" : "# NEEDS ATTENTION\n\nAutomatically generated by Sneebly when issues arise during autonomous development.\n\n---\n\n";
    const entry = `## Cycle ${cycle} — ${result} (${timestamp})\n- **Step**: ${step || "N/A"}\n- **Error**: ${error || "Unknown"}\n\n`;
    fs.appendFileSync(NEEDS_ATTENTION_FILE, header + entry, "utf-8");
  } catch (e) {
    console.log(`[Autonomy] Failed to write NEEDS-ATTENTION.md: ${(e as Error).message}`);
  }
}

function writePlanReviewSummary(plan: any, journal: SessionJournal, review?: ReviewResult): void {
  try {
    const timestamp = new Date().toISOString();
    const successes = journal.entries.filter(e => e.result === "success").length;
    const failures = journal.entries.filter(e => e.result.includes("failed")).length;
    const filesModified = Array.from(new Set(journal.entries.flatMap(e => e.filesModified)));
    const totalCost = journal.entries.reduce((sum, e) => sum + e.costThisCycle, 0);
    const errors = journal.entries.filter(e => e.error).map(e => `- ${e.error}`).join("\n");

    const reviewSection = review
      ? `\n**Opus Review**: ${review.summary}\n**Refactoring needed**: ${review.needsRefactoring ? "Yes — " + review.refactorInstructions.length + " issue(s) auto-fixed" : "No — code passed review"}\n`
      : "";

    const header = fs.existsSync(NEEDS_ATTENTION_FILE) ? "" : "# NEEDS ATTENTION\n\nAutomatically generated by Sneebly after plan completion and Opus review.\n\n---\n\n";
    const summary = `## Plan Complete — Reviewed & Paused (${timestamp})

**Goal**: ${plan.goal}

**Results**: ${successes} steps succeeded, ${failures} steps failed
**Cost**: $${totalCost.toFixed(4)}
**Files Modified**: ${filesModified.length > 0 ? filesModified.join(", ") : "None persisted"}
${reviewSection}
${errors ? `**Errors encountered**:\n${errors}\n` : ""}
**Action**: Resume the autonomy loop via the dashboard or API (\`POST /sneebly/autonomy/resume\`) to start the next plan.

---

`;
    fs.appendFileSync(NEEDS_ATTENTION_FILE, header + summary, "utf-8");
    console.log("[Autonomy] Review summary written to NEEDS-ATTENTION.md");
  } catch (e) {
    console.log(`[Autonomy] Failed to write review summary: ${(e as Error).message}`);
  }
}

interface ReviewResult {
  needsRefactoring: boolean;
  summary: string;
  refactorInstructions: Array<{
    filePath: string;
    issue: string;
    fix: string;
  }>;
}

function readFileSafe(filePath: string): string {
  try {
    const resolved = path.resolve(process.cwd(), filePath);
    if (!fs.existsSync(resolved)) return `[File does not exist: ${filePath}]`;
    const content = fs.readFileSync(resolved, "utf-8");
    if (content.length > 15000) return content.slice(0, 15000) + "\n[TRUNCATED]";
    return content;
  } catch {
    return `[Cannot read: ${filePath}]`;
  }
}

async function opusReviewPlan(plan: any, journal: SessionJournal): Promise<ReviewResult> {
  const filesModified = Array.from(new Set(journal.entries.flatMap(e => e.filesModified)));
  const existingFiles = filesModified.filter(f => fs.existsSync(path.resolve(process.cwd(), f)));

  if (existingFiles.length === 0) {
    return { needsRefactoring: false, summary: "No files to review", refactorInstructions: [] };
  }

  const fileContents = existingFiles.map(f => `=== ${f} ===\n${readFileSafe(f)}`).join("\n\n");

  const prompt = `You are a senior code reviewer. A plan just completed with this goal:

"${plan.goal}"

The following files were created or modified during the plan. Review them for:
1. TypeScript compilation errors (missing imports, type mismatches, wrong function signatures)
2. Dead code or unused imports
3. Missing error handling
4. Inconsistency with existing patterns in the codebase
5. Security issues (exposed secrets, SQL injection, etc.)

## Files to Review
${fileContents}

Respond in JSON:
{
  "needsRefactoring": true/false,
  "summary": "Brief assessment of code quality",
  "refactorInstructions": [
    {
      "filePath": "path/to/file.ts",
      "issue": "What's wrong",
      "fix": "What to do about it"
    }
  ]
}

Only set needsRefactoring to true if there are actual bugs, TypeScript errors, or significant issues. Minor style preferences are NOT worth refactoring.`;

  console.log("[Autonomy/Review] Opus reviewing plan output...");

  try {
    const result = await callClaude(prompt, {
      model: "claude-opus-4-6",
      maxTokens: 8192,
      temperature: 0.2,
      agent: "reviewer-opus",
      task: "plan-review",
      feature: "autonomy-review",
    });

    const parsed = extractJson(result.text);
    if (parsed && typeof parsed.needsRefactoring === "boolean") {
      console.log(`[Autonomy/Review] Opus verdict: ${parsed.needsRefactoring ? "NEEDS REFACTORING" : "LOOKS GOOD"} — ${parsed.summary}`);
      return parsed as ReviewResult;
    }
    console.log("[Autonomy/Review] Could not parse Opus review response");
    return { needsRefactoring: false, summary: "Review parse failed", refactorInstructions: [] };
  } catch (err: any) {
    console.log(`[Autonomy/Review] Opus review error: ${err.message}`);
    return { needsRefactoring: false, summary: `Review error: ${err.message}`, refactorInstructions: [] };
  }
}

async function autoRefactor(review: ReviewResult): Promise<{ filesModified: string[]; success: boolean }> {
  const filesModified: string[] = [];
  const safePaths = getSafePaths();
  const neverModify = getNeverModifyPaths();

  for (const instruction of review.refactorInstructions) {
    if (!isPathSafe(instruction.filePath, safePaths, neverModify)) {
      console.log(`[Autonomy/Refactor] Skipped unsafe path: ${instruction.filePath}`);
      continue;
    }

    const currentContent = readFileSafe(instruction.filePath);
    if (currentContent.startsWith("[")) continue;

    const prompt = `Refactor this file to fix the following issue.

## Issue
${instruction.issue}

## Fix Required
${instruction.fix}

## Current File
=== ${instruction.filePath} ===
${currentContent}

Output the COMPLETE fixed file content. Preserve all existing functionality. Only fix the specific issue described.

Respond in JSON:
{
  "fileChanges": [
    { "filePath": "${instruction.filePath}", "content": "complete file content" }
  ]
}`;

    try {
      console.log(`[Autonomy/Refactor] Fixing: ${instruction.filePath} — ${instruction.issue}`);
      const result = await callClaude(prompt, {
        model: "claude-opus-4-6",
        maxTokens: 16000,
        temperature: 0.2,
        agent: "refactor-opus",
        task: `refactor-${instruction.filePath}`,
        feature: "autonomy-refactor",
      });

      const parsed = extractJson(result.text);
      if (parsed?.fileChanges) {
        for (const change of parsed.fileChanges) {
          if (!isPathSafe(change.filePath, safePaths, neverModify)) continue;
          const fullPath = path.resolve(process.cwd(), change.filePath);
          const dir = path.dirname(fullPath);
          if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
          if (fs.existsSync(fullPath)) {
            const backupDir = path.join(process.cwd(), ".sneebly", "backups", "refactor");
            if (!fs.existsSync(backupDir)) fs.mkdirSync(backupDir, { recursive: true });
            const safeName = change.filePath.replace(/[\/\\]/g, "__");
            fs.copyFileSync(fullPath, path.join(backupDir, `${safeName}.${Date.now()}.bak`));
          }
          fs.writeFileSync(fullPath, change.content, "utf-8");
          filesModified.push(change.filePath);
          console.log(`[Autonomy/Refactor] Updated: ${change.filePath}`);
        }
      }
    } catch (err: any) {
      console.log(`[Autonomy/Refactor] Error fixing ${instruction.filePath}: ${err.message}`);
    }
  }

  return { filesModified, success: filesModified.length > 0 };
}

const JOURNAL_FILE = path.join(process.cwd(), ".sneebly", "session-journal.json");

interface JournalEntry {
  cycle: number;
  timestamp: string;
  result: string;
  stepDescription: string | null;
  filesModified: string[];
  error: string | null;
  costThisCycle: number;
  usedOpus: boolean;
  verificationPassed: boolean | null;
  autoFixerTriggered: boolean;
  retryContext: string | null;
}

interface SessionJournal {
  sessionId: string;
  startedAt: string;
  entries: JournalEntry[];
  totalCost: number;
  totalFilesModified: number;
  successCount: number;
  failCount: number;
}

function loadJournal(): SessionJournal | null {
  try {
    if (fs.existsSync(JOURNAL_FILE)) {
      return JSON.parse(fs.readFileSync(JOURNAL_FILE, "utf-8"));
    }
  } catch {}
  return null;
}

function saveJournal(journal: SessionJournal): void {
  const dir = path.dirname(JOURNAL_FILE);
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
  fs.writeFileSync(JOURNAL_FILE, JSON.stringify(journal, null, 2), "utf-8");
}

function createJournal(): SessionJournal {
  return {
    sessionId: `session-${Date.now()}`,
    startedAt: new Date().toISOString(),
    entries: [],
    totalCost: 0,
    totalFilesModified: 0,
    successCount: 0,
    failCount: 0,
  };
}

function pruneJournal(journal: SessionJournal): void {
  const MAX = 200;
  if (journal.entries.length <= MAX) return;

  const removed = journal.entries.slice(0, journal.entries.length - MAX);
  journal.entries = journal.entries.slice(-MAX);

  try {
    const today = new Date().toISOString().slice(0, 10);
    const archivePath = path.join(process.cwd(), '.sneebly', 'daily', `${today}-journal.jsonl`);
    const dir = path.dirname(archivePath);
    if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });

    const lines = removed.map(e => JSON.stringify(e)).join('\n') + '\n';
    fs.appendFileSync(archivePath, lines);
  } catch (e) {
    console.log(`[Autonomy] Failed to archive journal entries: ${(e as Error).message}`);
  }
}

function addJournalEntry(journal: SessionJournal, entry: JournalEntry): void {
  journal.entries.push(entry);
  journal.totalCost += entry.costThisCycle;
  journal.totalFilesModified += entry.filesModified.length;
  if (entry.result === "success") journal.successCount++;
  if (["build-failed", "verify-failed", "error", "planner-failed"].includes(entry.result)) journal.failCount++;
  pruneJournal(journal);
  saveJournal(journal);
}

function getRecentFailureContext(journal: SessionJournal, limit = 3): string | null {
  const recent = journal.entries
    .filter(e => ["build-failed", "verify-failed", "error", "planner-failed"].includes(e.result))
    .slice(-limit);
  if (recent.length === 0) return null;
  return recent
    .map(e => `[Cycle ${e.cycle}] ${e.result}: ${e.error || "unknown"} (step: ${e.stepDescription || "none"})`)
    .join("\n");
}

export function getSessionJournal(): SessionJournal | null {
  return loadJournal();
}

export function getRecentJournalEntries(limit = 20): JournalEntry[] {
  const journal = loadJournal();
  if (!journal) return [];
  return journal.entries.slice(-limit).reverse();
}

interface AutonomyState {
  running: boolean;
  paused: boolean;
  currentCycle: number;
  totalCycles: number;
  lastCycleResult: string | null;
  lastCycleTime: string | null;
  errors: string[];
  filesModified: string[];
}

const state: AutonomyState = {
  running: false,
  paused: false,
  currentCycle: 0,
  totalCycles: 0,
  lastCycleResult: null,
  lastCycleTime: null,
  errors: [],
  filesModified: [],
};

let loopInterval: ReturnType<typeof setInterval> | null = null;
let currentJournal: SessionJournal | null = null;

const MAX_CYCLES_PER_SESSION = 50;
const MIN_CYCLE_INTERVAL_MS = 120000;
const MAX_ERRORS_BEFORE_PAUSE = 5;
const MAX_ERRORS_STORED = 50;
let lastCycleStartTime = 0;

function pushError(msg: string): void {
  state.errors.push(msg);
  if (state.errors.length > MAX_ERRORS_STORED) {
    state.errors = state.errors.slice(-MAX_ERRORS_STORED);
  }
}

function checkBudget(): boolean {
  const { max } = getBudgetLimits();
  const summary = getCostSummary();
  if (summary.totalAllTime >= max) {
    console.log(`[Autonomy] Budget exceeded: $${summary.totalAllTime.toFixed(4)} >= $${max} limit`);
    return false;
  }
  return true;
}

async function runCycle(): Promise<string> {
  if (state.paused) return "paused";
  if (!checkBudget()) {
    state.paused = true;
    return "budget-exceeded";
  }
  if (state.currentCycle >= MAX_CYCLES_PER_SESSION) {
    state.paused = true;
    return "max-cycles-reached";
  }

  const now = Date.now();
  if (now - lastCycleStartTime < MIN_CYCLE_INTERVAL_MS) return "rate-limited";
  lastCycleStartTime = now;

  state.currentCycle++;
  state.totalCycles++;
  console.log(`[Autonomy] === Cycle ${state.currentCycle} ===`);

  if (!currentJournal) currentJournal = loadJournal() || createJournal();
  const costBefore = getCostSummary().totalAllTime;

  const entry: JournalEntry = {
    cycle: state.currentCycle,
    timestamp: new Date().toISOString(),
    result: "unknown",
    stepDescription: null,
    filesModified: [],
    error: null,
    costThisCycle: 0,
    usedOpus: false,
    verificationPassed: null,
    autoFixerTriggered: false,
    retryContext: null,
  };

  const failureContext = getRecentFailureContext(currentJournal);
  if (failureContext) {
    entry.retryContext = failureContext;
  }

  try {
    const healthy = await quickHealthCheck();
    if (!healthy) {
      pushError(`Cycle ${state.currentCycle}: Server not healthy`);
      if (state.errors.length >= MAX_ERRORS_BEFORE_PAUSE) state.paused = true;
      entry.result = "unhealthy";
      entry.error = "Server not healthy";
      entry.costThisCycle = getCostSummary().totalAllTime - costBefore;
      addJournalEntry(currentJournal, entry);
      return "unhealthy";
    }

    let plan = loadCurrentPlan();
    if (!plan || plan.status !== "active") {
      console.log("[Autonomy] Opus generating new plan...");
      try {
        plan = await generatePlan(failureContext || undefined);
      } catch (error: any) {
        pushError(`Cycle ${state.currentCycle}: Planner failed — ${error.message}`);
        entry.result = "planner-failed";
        entry.error = error.message;
        entry.costThisCycle = getCostSummary().totalAllTime - costBefore;
        addJournalEntry(currentJournal, entry);
        return "planner-failed";
      }
    }

    const nextStep = getNextStep();
    if (!nextStep) {
      console.log("[Autonomy] Plan complete — Opus reviewing before next plan...");

      try {
        await markGoalComplete(plan.goal);
        generateProgressReport();
      } catch (e) {
        console.log('[sneebly] Could not mark goal:', (e as Error).message);
      }

      const review = await opusReviewPlan(plan, currentJournal!);

      if (review.needsRefactoring && review.refactorInstructions.length > 0) {
        console.log(`[Autonomy] Opus found ${review.refactorInstructions.length} issue(s) — auto-refactoring...`);
        const refactorResult = await autoRefactor(review);

        if (refactorResult.filesModified.length > 0) {
          console.log(`[Autonomy] Refactored ${refactorResult.filesModified.length} file(s) — verifying...`);
          const verifyResult = await verifyChanges(refactorResult.filesModified);
          if (!verifyResult.allPassed) {
            console.log("[Autonomy] Refactor verification failed — rolling back refactor changes");
            rollbackFiles(refactorResult.filesModified);
          } else {
            console.log("[Autonomy] Refactor verified successfully");
          }
        }

        writePlanReviewSummary(plan, currentJournal!, review);
      } else {
        console.log("[Autonomy] Opus review: code looks good — continuing to next plan");
        writePlanReviewSummary(plan, currentJournal!, review);
      }

      console.log("[Autonomy] Plan reviewed — will generate next plan on next cycle");

      entry.result = "plan-complete-reviewed";
      entry.costThisCycle = getCostSummary().totalAllTime - costBefore;
      addJournalEntry(currentJournal, entry);
      return "plan-complete-reviewed";
    }

    entry.stepDescription = nextStep.description;
    console.log(`[Autonomy] Opus building: ${nextStep.description}`);

    let stepContext = failureContext || undefined;
    if ((nextStep as any).lastError && (nextStep as any).failCount && (nextStep as any).failCount > 0) {
      const retryNote = `\n\nIMPORTANT — This step is being RETRIED (attempt ${((nextStep as any).failCount || 0) + 1}). Previous error: ${(nextStep as any).lastError}\nDo NOT repeat the same approach. Try a different strategy to accomplish the goal.`;
      stepContext = (stepContext || "") + retryNote;
    }

    const buildResult = await executeStep(nextStep, stepContext);

    if (!buildResult.success) {
      if (buildResult.filesModified.length > 0) {
        console.log("[Autonomy] Build failed with partial changes — rolling back step files...");
        const rolledBack = rollbackFiles(buildResult.filesModified);
        if (rolledBack.length > 0) {
          console.log(`[Autonomy] Rolled back ${rolledBack.length} file(s): ${rolledBack.join(", ")}`);
        }
      }

      pushError(`Cycle ${state.currentCycle}: Build failed — ${buildResult.error}`);

      const { markStepFailed: markFailed2 } = require("./planner-agent");
      markFailed2(nextStep.id, buildResult.error || "Build produced no changes");

      const planAfterFail = loadCurrentPlan();
      const stepAfterFail = planAfterFail?.steps.find(s => s.id === nextStep.id);
      if (stepAfterFail?.status === "pending") {
        console.log(`[Autonomy] Step "${nextStep.id}" will be retried next cycle (attempt ${stepAfterFail.failCount || 1})`);
      } else if (stepAfterFail?.status === "skipped") {
        console.log(`[Autonomy] Step "${nextStep.id}" skipped after max failures — plan continues`);
        state.errors = [];
      }

      entry.result = "build-failed";
      entry.error = buildResult.error || "Build produced no changes";
      entry.costThisCycle = getCostSummary().totalAllTime - costBefore;
      addJournalEntry(currentJournal, entry);
      return "build-failed";
    }

    entry.filesModified = buildResult.filesModified;
    entry.usedOpus = !!buildResult.usedOpus;
    state.filesModified.push(...buildResult.filesModified);

    if (buildResult.filesModified.length > 0) {
      console.log("[Autonomy] Quick-verifying step changes...");
      const stepVerify = await quickStepVerify(buildResult.filesModified);

      if (!stepVerify.passed) {
        console.log(`[Autonomy] Step verification issues: ${stepVerify.errors.join("; ")}`);

        console.log("[Autonomy] Rolling back step files...");
        const rolledBack = rollbackFiles(buildResult.filesModified);
        if (rolledBack.length > 0) {
          console.log(`[Autonomy] Rolled back ${rolledBack.length} file(s): ${rolledBack.join(", ")}`);
        }

        const { markStepFailed } = require("./planner-agent");
        markStepFailed(nextStep.id, `Step verification failed: ${stepVerify.errors.slice(0, 3).join("; ")}`);

        pushError(`Cycle ${state.currentCycle}: Step verification failed — ${stepVerify.errors[0]}`);
        entry.result = "verify-failed";
        entry.error = `Step verification: ${stepVerify.errors.slice(0, 3).join("; ")}`;
        entry.verificationPassed = false;
        entry.costThisCycle = getCostSummary().totalAllTime - costBefore;
        addJournalEntry(currentJournal, entry);
        return "verify-failed";
      }

      entry.verificationPassed = true;
    }

    const healthyAfterStep = await quickHealthCheck();
    if (!healthyAfterStep) {
      console.log("[Autonomy] Server unhealthy after step — rolling back...");
      if (buildResult.filesModified.length > 0) {
        rollbackFiles(buildResult.filesModified);
      }
      const { markStepFailed: markFailed } = require("./planner-agent");
      markFailed(nextStep.id, "Server became unhealthy after changes");
      entry.result = "verify-failed";
      entry.error = "Server became unhealthy after changes";
      entry.verificationPassed = false;
      entry.costThisCycle = getCostSummary().totalAllTime - costBefore;
      addJournalEntry(currentJournal, entry);
      return "verify-failed";
    }

    state.errors = [];
    entry.result = "success";
    entry.costThisCycle = getCostSummary().totalAllTime - costBefore;
    addJournalEntry(currentJournal, entry);

    if (currentJournal.successCount > 0 && currentJournal.successCount % 5 === 0) {
      try {
        await runLearningCycle();
        console.log('[sneebly] Learning cycle completed');
      } catch (e) {
        console.log('[sneebly] Learning cycle skipped:', (e as Error).message);
      }
    }

    return "success";
  } catch (error: any) {
    if (error.name === 'BudgetExceeded') {
      console.log('[sneebly] Budget exceeded — pausing loop');
      pauseAutonomyLoop();
      entry.result = "error";
      entry.error = "Budget exceeded — loop paused";
      entry.costThisCycle = getCostSummary().totalAllTime - costBefore;
      addJournalEntry(currentJournal, entry);
      return "error";
    }
    pushError(`Cycle ${state.currentCycle}: ${error.message}`);
    console.error(`[Autonomy] Cycle error:`, error);
    if (state.errors.length >= MAX_ERRORS_BEFORE_PAUSE) state.paused = true;
    entry.result = "error";
    entry.error = error.message;
    entry.costThisCycle = getCostSummary().totalAllTime - costBefore;
    addJournalEntry(currentJournal, entry);
    return "error";
  }
}

export function startAutonomyLoop(intervalMs = MIN_CYCLE_INTERVAL_MS): void {
  if (loopInterval) return;

  state.running = true;
  state.paused = false;
  state.currentCycle = 0;
  state.errors = [];
  currentJournal = createJournal();
  saveJournal(currentJournal);

  console.log(`[Autonomy] Starting loop (Opus plans, Sonnet builds, Opus reviews)`);

  setTimeout(async () => {
    const result = await runCycle();
    state.lastCycleResult = result;
    state.lastCycleTime = new Date().toISOString();
    console.log(`[Autonomy] First cycle: ${result}`);
  }, 15000);

  loopInterval = setInterval(async () => {
    if (state.paused) return;
    const result = await runCycle();
    state.lastCycleResult = result;
    state.lastCycleTime = new Date().toISOString();
    console.log(`[Autonomy] Cycle result: ${result}`);
  }, intervalMs);
}

export function stopAutonomyLoop(): void {
  if (loopInterval) {
    clearInterval(loopInterval);
    loopInterval = null;
  }
  state.running = false;
  state.paused = false;
  console.log("[Autonomy] Loop stopped");
}

export function pauseAutonomyLoop(): void {
  state.paused = true;
  console.log("[Autonomy] Loop paused");
}

export function resumeAutonomyLoop(): void {
  state.paused = false;
  state.errors = [];
  console.log("[Autonomy] Loop resumed");
}

export function getAutonomyState(): AutonomyState & { completionPercent: number } {
  return { ...state, completionPercent: getCompletionPercent() };
}

export async function triggerSingleCycle(): Promise<string> {
  if (state.paused && state.errors.length >= MAX_ERRORS_BEFORE_PAUSE) {
    return "paused-safety-requires-resume";
  }
  if (state.paused) state.paused = false;
  const savedTime = lastCycleStartTime;
  lastCycleStartTime = 0;
  const result = await runCycle();
  if (result === "rate-limited") lastCycleStartTime = savedTime;
  state.lastCycleResult = result;
  state.lastCycleTime = new Date().toISOString();
  return result;
}
