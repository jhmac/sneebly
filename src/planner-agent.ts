import fs from "fs";
import path from "path";
import { getSafePaths } from "./identity";
import { getCompletionPercent } from "./progress-tracker";
import { extractJson, callClaude } from "./utils";
import { validateSpec } from "./spec-validator";

const PLAN_FILE = path.join(process.cwd(), ".sneebly", "current-plan.json");
const GOALS_FILE = path.join(process.cwd(), "GOALS.md");

export interface PlanStep {
  id: string;
  action: "create" | "modify" | "append";
  filePath: string;
  description: string;
  dependsOn: string[];
  status: "pending" | "in_progress" | "done" | "failed" | "skipped";
  failCount?: number;
  skipReason?: string;
}

export interface Plan {
  id: string;
  goal: string;
  phase: string;
  steps: PlanStep[];
  createdAt: string;
  status: "active" | "completed" | "failed" | "cancelled";
}

function readGoals(): string {
  try {
    return fs.readFileSync(GOALS_FILE, "utf-8");
  } catch {
    return "";
  }
}

function readFile(filePath: string, maxLines = 150): string {
  try {
    const resolved = path.resolve(process.cwd(), filePath);
    if (!fs.existsSync(resolved)) return `[Does not exist]`;
    const lines = fs.readFileSync(resolved, "utf-8").split("\n");
    return lines.slice(0, maxLines).join("\n") + (lines.length > maxLines ? "\n...[truncated]" : "");
  } catch {
    return `[Cannot read]`;
  }
}

export function loadCurrentPlan(): Plan | null {
  try {
    if (fs.existsSync(PLAN_FILE)) {
      return JSON.parse(fs.readFileSync(PLAN_FILE, "utf-8"));
    }
  } catch {}
  return null;
}

export function savePlan(plan: Plan): void {
  const dir = path.dirname(PLAN_FILE);
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
  fs.writeFileSync(PLAN_FILE, JSON.stringify(plan, null, 2), "utf-8");
}

export async function generatePlan(failureContext?: string): Promise<Plan> {
  const goals = readGoals();
  const schema = readFile("shared/schema.ts", 200);

  const goalsExcerpt = goals.length > 6000 ? goals.slice(0, 6000) + "\n...[truncated]" : goals;

  const safeTargets = getSafePaths().join(", ");

  let memoryContext = "";
  try {
    const { getMemoryForPrompt } = require("./memory-manager");
    const memory = getMemoryForPrompt(["Conventions", "Fix Patterns", "Mistakes"]);
    if (memory) memoryContext = `\n## Learned Conventions & Patterns\n${memory}\n`;
  } catch {}

  let blockerContext = "";
  try {
    const { getActiveBlockerCount } = require("./spec-monitor");
    const count = getActiveBlockerCount();
    if (count > 0) blockerContext = `\n## Active Blockers: ${count}\n`;
  } catch {}

  let completionContext = "";
  try {
    const pct = getCompletionPercent();
    if (pct > 0) completionContext = `\n## Current Completion: ${pct}%\n`;
  } catch {}

  const failureSection = failureContext
    ? `\n## Recent Failures (DO NOT repeat these mistakes)\n${failureContext}\n`
    : "";

  let journalContext = "";
  try {
    const { getRecentJournalEntries } = require("./autonomy-loop");
    const entries = getRecentJournalEntries(3);
    if (entries.length > 0) {
      journalContext = `\n## Recent Cycle History\n${entries.map((e: any) => `- Cycle ${e.cycle}: ${e.result}${e.stepDescription ? ` (${e.stepDescription})` : ""}${e.error ? ` — ${e.error}` : ""}`).join("\n")}\n`;
    }
  } catch {}

  const prompt = `Analyze what's been built and plan what to build next.

## GOALS.md
${goalsExcerpt}

## Current Schema (shared/schema.ts, first 200 lines)
${schema}
${memoryContext}${blockerContext}${completionContext}${journalContext}${failureSection}
Pick the single highest-priority missing feature. Break it into concrete steps (max 6).
Only target files in safe paths: ${safeTargets}

CRITICAL RULES:
- NEVER create migration SQL files (drizzle/*.sql, migrations/*.sql). Migrations are auto-generated by running "npx drizzle-kit push" after schema changes.
- NEVER create split type files (shared/types/*.ts, shared/models/*.ts). All types come from shared/schema.ts via Drizzle inference.
- For database changes: (1) modify shared/schema.ts, (2) add a shellCommand step for "npx drizzle-kit push".
- Steps that need CLI commands should include "shellCommands" in the description (e.g., "Run npx drizzle-kit push to sync database").

Respond in JSON:
{
  "goal": "What we're building",
  "phase": "Which phase",
  "steps": [
    { "id": "step-1", "action": "create|modify|append", "filePath": "path", "description": "What to do", "dependsOn": [] }
  ]
}`;

  const result = await callClaude(prompt, {
    model: "claude-opus-4-6",
    maxTokens: 8192,
    temperature: 0.3,
    effort: "high",
    agent: "planner-opus",
    task: "plan-generation",
    feature: "autonomy-plan",
  });

  const planData = extractJson(result.text);
  if (!planData) throw new Error("Planner did not return valid JSON");

  const rawSteps = (planData.steps || []).map((s: any) => ({ ...s, status: "pending" as const }));

  const validatedSteps: PlanStep[] = [];
  for (const step of rawSteps) {
    const validation = validateSpec({ filePath: step.filePath, description: step.description, action: step.action });
    if (validation.action === "redirect" && validation.correctedSpec) {
      console.log(`[Planner] Auto-corrected step "${step.id}": ${step.filePath} → ${validation.correctedSpec.filePath} (${validation.reason})`);
      validatedSteps.push({
        ...step,
        filePath: validation.correctedSpec.filePath,
        action: validation.correctedSpec.action || step.action,
        description: validation.correctedSpec.description || step.description,
      });
    } else if (validation.action === "reject") {
      console.log(`[Planner] Removed invalid step "${step.id}": ${validation.reason}`);
    } else {
      validatedSteps.push(step);
    }
  }

  if (validatedSteps.length === 0 && rawSteps.length > 0) {
    throw new Error("All plan steps were invalid and removed by validation");
  }

  const plan: Plan = {
    id: `plan-${Date.now()}`,
    goal: planData.goal || "Unknown goal",
    phase: planData.phase || "Unknown phase",
    steps: validatedSteps,
    createdAt: new Date().toISOString(),
    status: "active",
  };

  savePlan(plan);
  console.log(`[Planner/Opus] Created plan: ${plan.goal} (${plan.steps.length} steps${rawSteps.length !== validatedSteps.length ? `, ${rawSteps.length - validatedSteps.length} corrected/removed` : ""})`);
  return plan;
}

export function getNextStep(): PlanStep | null {
  const plan = loadCurrentPlan();
  if (!plan || plan.status !== "active") return null;

  for (const step of plan.steps) {
    if (step.status !== "pending") continue;

    const depsReady = step.dependsOn.every(dep => {
      const depStep = plan.steps.find(s => s.id === dep);
      return depStep?.status === "done" || depStep?.status === "skipped";
    });

    if (depsReady) return step;
  }

  const allDone = plan.steps.every(s => s.status === "done" || s.status === "skipped" || s.status === "failed");
  if (allDone) {
    const doneCount = plan.steps.filter(s => s.status === "done").length;
    if (doneCount > 0) {
      plan.status = "completed";
      savePlan(plan);
      console.log(`[Planner] Plan auto-completed: ${doneCount}/${plan.steps.length} steps done`);
    }
  }

  return null;
}

export function markStepDone(stepId: string): void {
  const plan = loadCurrentPlan();
  if (!plan) return;
  const step = plan.steps.find(s => s.id === stepId);
  if (step) step.status = "done";
  if (plan.steps.every(s => s.status === "done")) {
    plan.status = "completed";
    console.log(`[Planner] Plan completed: ${plan.goal}`);
  }
  savePlan(plan);
}

const MAX_STEP_FAILURES = 2;

export function markStepFailed(stepId: string): void {
  const plan = loadCurrentPlan();
  if (!plan) return;
  const step = plan.steps.find(s => s.id === stepId);
  if (!step) return;

  step.failCount = (step.failCount || 0) + 1;

  if (step.failCount >= MAX_STEP_FAILURES) {
    step.status = "skipped";
    step.skipReason = `Skipped after ${step.failCount} failed attempts`;
    console.log(`[Planner] Step ${stepId} skipped after ${step.failCount} failures — continuing plan`);

    const hasRemainingWork = plan.steps.some(s => {
      if (s.status !== "pending") return false;
      const depOnSkipped = s.dependsOn.includes(stepId);
      if (depOnSkipped) return false;
      return true;
    });

    for (const s of plan.steps) {
      if (s.status === "pending" && s.dependsOn.includes(stepId)) {
        s.status = "skipped";
        s.skipReason = `Dependency ${stepId} was skipped`;
        console.log(`[Planner] Step ${s.id} skipped (depends on skipped step ${stepId})`);
      }
    }

    if (!hasRemainingWork) {
      const doneCount = plan.steps.filter(s => s.status === "done").length;
      if (doneCount > 0) {
        plan.status = "completed";
        console.log(`[Planner] Plan completed with ${doneCount}/${plan.steps.length} steps done (rest skipped)`);
      } else {
        plan.status = "failed";
        console.log(`[Planner] Plan failed — all steps skipped or failed`);
      }
    }
  } else {
    step.status = "pending";
    console.log(`[Planner] Step ${stepId} failed (attempt ${step.failCount}/${MAX_STEP_FAILURES}) — will retry`);
  }

  savePlan(plan);
}

export function markStepInProgress(stepId: string): void {
  const plan = loadCurrentPlan();
  if (!plan) return;
  const step = plan.steps.find(s => s.id === stepId);
  if (step) step.status = "in_progress";
  savePlan(plan);
}

export function cancelPlan(): void {
  const plan = loadCurrentPlan();
  if (!plan) return;
  plan.status = "cancelled";
  savePlan(plan);
}
